

// ===== Arquivo: container\container.ts =====

// container/container.ts
import { Container } from "inversify";
import { TYPES } from "./types";
import { WinstonLoggerProd } from "../infra/logger/WinstonLoggerProd";
import { WinstonLoggerDev } from "../infra/logger/WinstonLoggerDev";
import { SmtpMailer } from "../infra/mailer/SmtpMailer";
import { EtherealMailer } from "../infra/mailer/EtherealMailer";
import { FakerReportDataGenerator } from "../infra/gerador_dados/FakerReportDataGenerator";
import { ReportServiceImpl } from "../domain/services/ReportServiceImpl";

const container = new Container();

if (process.env.APP_ENV === "prod") {
  container.bind(TYPES.Logger).to(WinstonLoggerProd).inSingletonScope();
  container.bind(TYPES.Mailer).to(SmtpMailer).inSingletonScope();
} else {
  container.bind(TYPES.Logger).to(WinstonLoggerDev).inSingletonScope();
  container.bind(TYPES.Mailer).to(EtherealMailer).inSingletonScope();
}

container.bind(TYPES.ReportDataGenerator)
  .to(FakerReportDataGenerator)
  .inSingletonScope();

container.bind(TYPES.ReportService)
  .to(ReportServiceImpl);

export { container };


// ===== Arquivo: container\types.ts =====

export type ReportRecord = {
  nome: string;
  cidade: string;
};

//Types do Inversify
export const TYPES = {
  Logger: Symbol.for("Logger"),
  Mailer: Symbol.for("Mailer"),
  ReportService: Symbol.for("ReportService"),
  ReportDataGenerator: Symbol.for("ReportDataGenerator"),
};

// ===== Arquivo: domain\errors\InvalidReportSizeError.ts =====

//Para Criar erros personalizados, utilizamos a classe built-in do JS "Error". 
export class InvalidReportSizeError extends Error {
  constructor() {
    super("O Parâmetro é inválido. Motivo provavel:\nNão foi informado um número.\nMenor que 1.\nMaior que 10.");
    this.name = "InvalidReportSizeError"; // só pra mostrar bonitinho o tipo do erro.
  }
}


// ===== Arquivo: domain\interfaces\Logger.ts =====

export interface Logger {
  info(message: string): void; //nível 1, só uma mensagem sendo passado
  warn(message: string): void; //nível 2, um alerta
  error(message: string): void; //nível3, deu ruim
}

// ===== Arquivo: domain\interfaces\Mailer.ts =====

export interface Mailer {
  send( to: string, //para quem
        subject: string, // assunto
        body: string):void // corpo do e-mail
    //Promise<void>;
}


// ===== Arquivo: domain\interfaces\ReportDataGenerator.ts =====

import { ReportRecord } from "../../container/types";

//Qualquer coisa que saiba gerar dados de relatório precisa ter esse método, seja por faker, banco de dados...
export interface ReportDataGenerator {
  generate(n: number): ReportRecord[];
}

// um método generate que recebe uma quantidade e devolve uma lista de ReportRecords

// ===== Arquivo: domain\interfaces\ReportService.ts =====

export interface ReportService {
  generateAndSend(email: string, n: number): Promise<void>;
}

// ===== Arquivo: domain\services\ReportServiceImpl.ts =====

import { InvalidReportSizeError } from "../errors/InvalidReportSizeError"
import { ReportDataGenerator } from "../interfaces/ReportDataGenerator";
import { Logger } from "../interfaces/Logger";
import { Mailer} from "../interfaces/Mailer"
import { ReportService } from "../interfaces/ReportService";
import { injectable, inject } from "inversify";
import { TYPES } from "../../container/types";

@injectable()
export class ReportServiceImpl implements ReportService {

  constructor(
    @inject(TYPES.ReportDataGenerator)
    private dataGenerator: ReportDataGenerator,

    @inject(TYPES.Logger)
    private logger: Logger,

    @inject(TYPES.Mailer)
    private mailer: Mailer
  ) {}

  async generateAndSend(email: string, n_registros: number): Promise<void> {
    this.validateReportSize(n_registros);

    this.logger.info(`Iniciando geração de relatório para ${n_registros} registros`);

    const report = this.dataGenerator.generate(n_registros);

    const body = report
      .map(r => `Nome: ${r.nome} - Cidade: ${r.cidade}`)
      .join("<br>");

    this.logger.info(`Enviando relatório para ${email}`);

    await this.mailer.send(email, "Relatório de Dados", body);

    this.logger.info(`Relatório enviado com sucesso para ${email}`);
  }

  private validateReportSize(n_registros: number): void {
    if (!Number.isInteger(n_registros) || n_registros < 1 || n_registros > 10) {
      throw new InvalidReportSizeError();
    }
  }
}

// ===== Arquivo: exportFiles.ts =====

import fs from "fs";
import path from "path";

const ROOT_DIR = path.resolve(__dirname, "../src"); // raiz do projeto
const OUTPUT_FILE = path.resolve(__dirname, "../all-files.txt");

function exportTsFiles(dir: string, collected: string[] = []): string[] {
  const entries = fs.readdirSync(dir);

  for (const entry of entries) {
    // Ignora node_modules
    if (entry === "node_modules") continue;

    const fullPath = path.join(dir, entry);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      exportTsFiles(fullPath, collected);
    } else if (stat.isFile() && entry.endsWith(".ts")) {
      collected.push(fullPath);
    }
  }

  return collected;
}

function generateSingleFile(): void {
  const files = exportTsFiles(ROOT_DIR);

  let output = "";

  for (const filePath of files) {
    const content = fs.readFileSync(filePath, "utf-8");
    const relativePath = path.relative(ROOT_DIR, filePath);

    output +=
      `\n\n// ===== Arquivo: ${relativePath} =====\n\n` +
      content;
  }

  fs.writeFileSync(OUTPUT_FILE, output, "utf-8");
  console.log("✅ Arquivos .ts exportados (node_modules ignorado)");
}

generateSingleFile();


// ===== Arquivo: http\ReportController.ts =====

// http/ReportController.ts
import { Router } from "express";
import { container } from "../container/container";
import { TYPES } from "../container/types";
import { ReportService } from "../domain/interfaces/ReportService";
import { InvalidReportSizeError } from "../domain/errors/InvalidReportSizeError";

const router = Router();

router.get("/relatorio/:n", async (req, res) => {
  try {
    const n = Number(req.params.n);
    const email = req.query.email as string;

    if (!email) {
      return res.status(400).send("Parâmetro email é obrigatório");
    }

    const service = container.get<ReportService>(TYPES.ReportService);

    await service.generateAndSend(email, n);

    return res.status(200).send("Relatório enviado com sucesso");
  } catch (error) {
    if (error instanceof InvalidReportSizeError) {
      return res.status(400).send(error.message);
    }

    return res.status(500).send("Erro interno do servidor");
  }
});

export { router as ReportController };


// ===== Arquivo: infra\gerador_dados\FakerReportDataGenerator.ts =====

import { fakerPT_PT } from "@faker-js/faker";
import { ReportDataGenerator } from "../../domain/interfaces/ReportDataGenerator";
import { ReportRecord } from "../../types"

/* Essa função cria quantas pessoas forem pedidas pra ela fornecer, porém a validação
é anterior a ela na classe ReportService, então ela não gerará mais de 10.
Primeiramente ela foi colocada antes da validação, mas e se o usuario pedisse 1.000.000
registros, sendo que só seriam exibidos 10? É gasto de processamento, por isso é melhor
ela após a validação */
export class FakerReportDataGenerator implements ReportDataGenerator {
  generate(n: number): ReportRecord[] {
    const records: ReportRecord[] = [];

    for (let i = 0; i < n; i++) {
      records.push({
        nome: fakerPT_PT.person.fullName(),
        cidade: fakerPT_PT.location.city()
      });
    }

    return records;
  }
}

// ===== Arquivo: infra\logger\WinstonLogger.ts =====

import { Logger } from "../../domain/interfaces/Logger"
import winston from "winston"

const logger = winston.createLogger({
  transports: [new winston.transports.Console()]
})

export class WinstonLogger implements Logger {
  info(msg: string) { logger.info(msg) }
  warn(msg: string) { logger.warn(msg) }
  error(msg: string) { logger.error(msg) }
}

// ===== Arquivo: infra\logger\WinstonLoggerDev.ts =====

//esse mandará informações para o console, será colorido
import { createLogger, format, transports } from "winston";
import { Logger } from "../../domain/interfaces/Logger";

export class WinstonLoggerDev implements Logger {
  private logger = createLogger({
    level: "info",
    //Definir o formato do Log (ele pode ser uma combinação de formatos)
    format: format.combine(
      format.colorize(),
      format.simple()
    ),

    //será exibido no console.
    transports: [new transports.Console()],
  });

  //severidade nível 1 = só informativo
  info(msg: string): void {
    this.logger.info(msg);
  }
  //severidade nível 2 = alerta
  warn(msg: string): void {
    this.logger.warn(msg);
  }
  //severidade nível 3 = error
  error(msg: string): void {
    this.logger.error(msg);
  }
}


// ===== Arquivo: infra\logger\WinstonLoggerProd.ts =====

//esse mandará as informações para um arquivo "app.log"

/*O Winston é um pacote para Node.Js muito útil para fazer logs de aplicações. Aqui será usado para fazer log de texto, mas ele pode ser também usando com banco de dados, ou logs para nuvem */
import { createLogger, format, transports } from "winston";
import { Logger } from "../../domain/interfaces/Logger";

export class WinstonLoggerProd implements Logger {
  private logger = createLogger({
    level: "info",
    format: format.combine(
      format.timestamp(),
      format.json()
    ),
    transports: [
      new transports.File({ filename: "app.log" })
    ],
  });

  info(msg: string): void {
    this.logger.info(msg);
  }

  warn(msg: string): void {
    this.logger.warn(msg);
  }

  error(msg: string): void {
    this.logger.error(msg);
  }
}


// ===== Arquivo: infra\mailer\EtherealMailer.ts =====

/*O Ethereal Email é um serviço de e-mail falso (mock) usado apenas para testes.*/
import nodemailer from 'nodemailer';
import { Mailer } from "../../domain/interfaces/Mailer";

export class EtherealMailer implements Mailer {
  async send(to: string, subject: string, body: string): Promise<void> {
    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    });

    const info = await transporter.sendMail({
      from: '"Relatórios" <no-reply@test.com>',
      to,
      subject,
      html: body,
    });

    console.log("Preview URL:", nodemailer.getTestMessageUrl(info));
  }
}


// ===== Arquivo: infra\mailer\NodemailerMailer.ts =====

import { Mailer } from "../../domain/interfaces/Mailer"
import nodemailer from "nodemailer"

const transporter = nodemailer.createTransport({ /* sua config */ })

export class NodemailerMailer implements Mailer {
  async send(to: string, subject: string, body: string): Promise<void> {
    await transporter.sendMail({
      to, subject, html: body, from: "no-reply@t6.com"
    })
  }
}


// ===== Arquivo: infra\mailer\SmtpMailer.ts =====

import nodemailer from "nodemailer";
import { Mailer } from "../../domain/interfaces/Mailer";

export class SmtpMailer implements Mailer {
  private transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: Number(process.env.SMTP_PORT),
    secure: false,
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
  });

  async send(to: string, subject: string, body: string): Promise<void> {
    await this.transporter.sendMail({
      from: process.env.SMTP_USER,
      to,
      subject,
      html: body,
    });
  }
}


// ===== Arquivo: main.ts =====

import "reflect-metadata";
import express from "express";
import { ReportController } from "./http/ReportController";

const app = express();

app.use(express.json());
app.use(ReportController);

app.listen(process.env.APP_PORT, () => {
  console.log(`Servidor rodando na porta ${process.env.APP_PORT}`);
});


// ===== Arquivo: testeethereal.ts =====

import nodemailer from 'nodemailer';

async function main() {
  const transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
        user: 'ethel.runolfsdottir@ethereal.email',
        pass: 'UAuSR3MVJDH9ZrQzkZ'
    }
});
  const oswaldino = "oswaldino"
  const info = await transporter.sendMail({
    from: oswaldino,
    to: 'Humberto@gessinger.com',
    subject: 'Trecho: Cifra Inifita Highway, Cifra Terra de Gigantes',
    text:  `
D
 Cento e dez
E
 Cento e vinte
F#m
 Cento e sessenta
D           E            F#m
 Só pra ver até quando   o motor agüenta
...
...

F#m                     E
       Nessa terra de gigantes
F#m                            E
        Que trocam vidas por diamantes
F#m                        A             B
        A juventude é uma banda numa propaganda de
        E     C#m  E  C#m
Refrigerantes
    </pre>
  `
  });

  console.log('Preview URL:', nodemailer.getTestMessageUrl(info));
}

main().catch(console.error);
